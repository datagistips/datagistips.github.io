---
title: "Dataviz notebook"
output: html_notebook
---

```{r}
library(tidyverse)
```


[Téléchargeons la donnée d'artificialisation depuis Box](https://cerema.app.box.com/v/pnb-action7-indicateurs-ff)
```{r}
f <- read.csv2("../data/obs_artif_conso_com_2009_2020_V2.csv")

```
Explorons la donnée rapidement :
```{r}
head(f)
```
Le séparateur n'a pas été trouvé.

Spécifions le séparateur :

```{r}
f <- read.csv2("../data/obs_artif_conso_com_2009_2020_V2.csv", sep=",")
```

Explorons la donnée :
```{r}
glimpse(f)
```
Il y a des soucis d'encodage ! La donnée est en UTF-8, et R considère par défaut que l'encodage est celui du système.

Spécifions l'encodage :
```{r}
f <- read.csv2("../data/obs_artif_conso_com_2009_2020_V2.csv", sep=",", encoding = "UTF-8")
```

Vérifions les noms de communes :
```{r}
head(f$idcomtxt, 10)
```
C'est bon :-)

## Exploration rapide du contenu
Explorons les colonnes :
```{r}
names(f)
```

Les colonnes NAF concernent les flux totaux. 

On a les flux, d'une année à l'autre, pour ces différentes années :
```{r}
colNames <- names(f)[grep("naf[0-9]{2}.*[0-9]{2}", names(f))]
gsub("naf([0-9]{2}).*([0-9]{2})", "\\1 -> \\2", colNames) %>% unique %>% sort
```

## 2009-2020
Pour le passage de l'année 2009 à 2020, la notation est différente. Par exemple, la colonne nafart0920 (et non naf09art20) compile le total des flux entre 2009 et 2020.

On s'intéressera aux flux de l'année 2009 à l'année 2020 :
```{r}
colNames <- names(f)[grep(".*0920", names(f))]
```

- `nafart` concerne le total des flux artificialisés
- `artact` concerne l'artificialisation vers l'activité
- `arthab` concerne l'artificialisation vers l'habitat
- `artmix` concerne l'artificialisation vers le mixte
- `artinc` concerne l'artificialisation vers une destination inconnue
- `artcom` est le flux d'artificialisation divisé par la surface de la commune. Il s'agit donc du pourcentage de commune artificialisée entre les deux années.

Nous nous intéresserons seulement aux flux d'artificialisation par type, donc à toutes les colonnes sauf nafart et artcom.

Nous gardons les colonnes de localisation en plus des colonnes qui nous intéressent :
```{r}
colFlux <- c("artact0920", "arthab0920", "artmix0920", "artinc0920")
colNames <- c("idcom", "idcomtxt", "iddep", "iddeptxt", "idreg", "idregtxt", colFlux)
f2 <- f[, colNames]
```

Nous aurions aussi pu utiliser des indexes comme ceci :
```{r eval=FALSE}
colNames <- c(1:6, "artact0920", "arthab0920", "artmix0920", "artinc0920")
2 <- f[, colNames]
```

Prenons la commune d'Aix-en-Provence :

```{r}
f3 <- f2 %>% filter(idcom == "13001")
```

Nous allons utiliser ggplot2 (pour grammar of graphics)

ggplot attend un data frame structuré différent, de type long (xxx : long vs wide).

Le type long attend des variables déclinées verticalement en lignes, le type wide attend un format plus conventionnel, avec les variables déclinées horizontalement en colonnes.

Pour transformer notre donnée en ligne, nous utilisons gather
```{r}
f4 <- gather(f3, "variable", "value", -idcom)
```

Voici à quoi ressemble maintenant notre donnée :
```{r}
f4
```

Sélectionnons seulement les lignes où nous avons les flux :
```{r}
f5 <- f4 %>% filter(str_detect(variable, "^art"))
f5
```


Nous pouvons maintenant représenter la donnée en camembert :

```{r}
library(ggplot2)
ggplot(f5, aes(x = "", 
               y = value, 
               fill = variable)) +
  geom_bar(stat = "identity", width = 1) +
  coord_polar("y", start = 0)
```

Voyons ce que cela donne avec des barres :
```{r}
ggplot(data = f5, aes(x = variable, y = value)) +
  geom_bar(stat = "identity", fill="steelblue")
```


```{r}
ggplot(data = f5, aes(x = variable, y = value)) +
  geom_bar(stat = "identity", fill="steelblue")
```


Nous pouvons créer des graphiques empilés :
```{r}
ggplot(data = f5, aes(x = idcom, y = value, fill = variable)) +
  geom_bar(stat = "identity", position = "stack")  # on change le type ici
```

Nous pouvons opérer quelques transformations sur le graphique :
```{r}
ggplot(data = f5, aes(x = idcom, y = value, fill = variable)) +
  geom_bar(stat = "identity", position = "stack") +
  geom_text(aes(x = idcom, y = value, label = value), 
            position = position_stack(vjust = 0.5),
            size = 4) +
    theme(axis.text.x=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks=element_blank(),
          axis.title.x=element_blank(),
          axis.title.y=element_blank(),
          # legend.position="none",
          panel.background=element_blank(),
          panel.border=element_blank(),
          panel.grid.major=element_blank(),
          panel.grid.minor=element_blank()) +
scale_fill_discrete( # !! scale_fill
  name = "Flux d'artificialisation 2009-2020",
  labels = c("Activité", "Habitat", "Inconnu", "Mixte")
  # ,
  # values=c("artact0920", "arthab0920","artmix0920", "artinc0920")
  )
```

Sélectionnons d'autres couleurs, plus neutres. Pour cela, utilisons la modélisation des couleurs Hue Chroma Luminance

http://hclwizard.org:3000/hclcolorpicker/

Le type de couleur est défini par hue, ou la teinte.  

- Pour le type activité, nous choisirons la couleur <span style='color:red'>rouge</span> (hue de 5)
- Pour le type habitat, la couleur <span style='color:red'>rouge</span> (hue de 220)
- pour le type mixte, la couleur magenta (en quelque sorte un mélange du rouge et du bleu) (hue de 270)
- Nous représenterons le type inconnu par du gris

Nous choisissons un chroma de 30 (chroma va de 0 à 360 pour les couleurs les plus vives). Gris a un chroma de 0.   
Nous choisissons une luminance de 80 (la luminosité va de 0 à 100 pour les couleurs les plus lumineuses).

En affectant les mêmes niveaux de chroma et de luminance, nous obteons une palette homogène.

```{r}
colorRed <- hcl(h = 4, c = 30, l = 80, fixup = TRUE)
colorBlue <- hcl(h = 220, c = 30, l = 80, fixup = TRUE)
colorMagenta <- hcl(h = 300, c = 30, l = 80, fixup = TRUE)
colorGrey <- hcl(h = 0, c = 0, l = 80, fixup = TRUE)
palette <- c(colorRed, colorBlue, colorMagenta, colorGrey)
demoplot(palette, "bar")
hclplot(palette)
```
!! Voir la palette

```{r}
ggplot(data = f5, aes(x = idcom, y = value, fill = variable)) +
  geom_bar(stat = "identity", position = "stack") +
  geom_text(aes(x = idcom, y = value, label = value), 
            # hjust = 0.5, 
            # vjust = 2, 
            position = position_stack(vjust = 0.5),
            size = 4) +
  # theme_minimal() +
    theme(axis.text.x=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks=element_blank(),
          axis.title.x=element_blank(),
          axis.title.y=element_blank(),
          # legend.position="none",
          panel.background=element_blank(),
          panel.border=element_blank(),
          panel.grid.major=element_blank(),
          panel.grid.minor=element_blank()) +
scale_fill_manual( # !! scale_fill
  name = "Flux d'artificialisation 2009-2020",
  labels = c("Activité", "Habitat", "Inconnu", "Mixte"),
  values=c(colorRed, colorBlue, colorGrey, colorMagenta)
  )
```


!! Inconnu : couleur grise
!!HCL

Finalement, nous pouvons créer une fonction qui crée le bar plot pour une commune donnée :
```{r}
library(glue)

makeBarPlot <- function(f2, codeInsee) {
  # Filtre selon le code Insee
  f3 <- f2 %>% filter(idcom == codeInsee)
  
  # Reformate le tableau
  f4 <- gather(f3, "variable", "value", -idcom)
  
  # Sélectionne les bonnes lignes
  f5 <- f4 %>% filter(str_detect(variable, "^art"))
  
  # Crée le plot
  g <- ggplot(data = f5, aes(x = idcom, y = value, fill = variable)) +
    geom_bar(stat = "identity", position = "stack") +
    geom_text(aes(x = idcom, y = value, label = value), 
              position = position_stack(vjust = 0.5),
              size = 4) +
      theme(axis.text.x=element_blank(),
            axis.text.y=element_blank(),
            axis.ticks=element_blank(),
            axis.title.x=element_blank(),
            axis.title.y=element_blank(),
            # legend.position="none",
            panel.background=element_blank(),
            panel.border=element_blank(),
            panel.grid.major=element_blank(),
            panel.grid.minor=element_blank()) +
  scale_fill_discrete( # !! scale_fill
    name = glue("Flux d'artificialisation 2009-2020 ({codeInsee})"), # code Insee
    labels = c("Activité", "Habitat", "Inconnu", "Mixte")
    )
  
  return(g)
}

f2 %>% makeBarPlot(codeInsee = "13001")

```
