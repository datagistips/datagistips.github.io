---
title: "Dataviz Notebook #1"
output: html_notebook
---

Chargeons la fameuse librairie tidyverse. Celle-ci contient des librairies essentielles telles que dplyr, magrittr (pour les pipes %>%),...
```{r}
library(tidyverse)
```

## Lecture
Lisons notre fichier de données :
```{r}
flux <- read_csv("../data/obs_artif_conso_com_2009_2020_V2.csv")
glimpse(flux)
```

## Contrôle
Un petit souci : la colonne surfcom20 est de type caractères.
```{r}
class(flux$surfcom20)
```

Recherchons les valeurs non numériques dans la colonne :
```{r}
w <- grep("^[0-9]*$", flux$surfcom20, perl = TRUE)
flux$surfcom20[-w]
```

Il s'agit des valeurs NULL.

Quels sont les départements pour lesquels on a cette valeur (et donc pour lesquels on n'a pas de surface) ?
```{r}
flux$iddep[-w]
```
Il s'agit des départemments d'Outre-Mer.

## Transformation
Transformons les la colonne surfcom20 :
```{r}
flux$surfcom20 <- as.integer(flux$surfcom20)
```

## Colonnes utiles
Nous nous intéresserons aux colonnes "arthab0920", "artact0920", "artmix0920", "artinc0920" qui comprennent les flux d'artificialisation par type (habitat, activité, mixte et inconnu) entre 2009 et 2020.

```{r}
myCols <- c("idcom", "idcomtxt", "iddep", "iddeptxt", "idreg", "idregtxt", "surfcom20",
            "arthab0920", "artact0920", "artmix0920", "artinc0920")
```

!! Sketch de l'application

## Préparation des données
Nous allons utiliser ggplot2 pour représenter les données. Celui-ci accepte des données au format long et non wide.

Prenons l'exemple d'Aix en Provence :
```{r}
fluxAix <- flux %>% filter(idcom == "13001")
kable(fluxAix[, myCols])

```

Pour transformer au format long, nous utilisons la fonction `gather` :

```{r}
library(knitr)
fluxAixL <- gather(fluxAix[, myCols], "variable", "value", 
                   c("arthab0920", "artact0920", "artmix0920", "artinc0920", "surfcom20"))
kable(fluxAixL)
```

Nous avons les statistiques pour la commune d'Aix en Provence.

### Bouches du Rhône
Nous pouvons calculer le même type de statistiques sur un département, par agrégation, en sommant les flux :

```{r}
fluxd13 <- flux[, myCols] %>% 
  filter(iddep == "13") %>% 
  summarize(iddep = first(iddep),
            iddeptxt = first(iddeptxt),
            idreg = first(idcom),
            idregtxt = first(idregtxt),
            arthab0920 = sum(arthab0920),
            artact0920 = sum(artact0920),
            artmix0920 = sum(artmix0920),
            artinc0920 = sum(artinc0920),
            surfcom20 = sum(surfcom20)) # !! not integer

fluxd13L <- gather(fluxd13, "variable", "value",
                   c("arthab0920", "artact0920", "artmix0920", "artinc0920", "surfcom20"))

kable(fluxd13L)
```


Nous pouvons faire quelque chose de plus fin en choisissant des communes particulières.

### Fonction
Profitons-en pour créer une fonction que nous utiliserons dans notre dashboard qui servira à calculer les stats agrégées pour l'ensemble des communes visibles sur la carte :

```{r}
getStatsComm <- function(flux, codesInsees) {
  fComms <- flux %>% 
    filter(idcom %in% codesInsees) %>% 
    summarize(idcom = list(idcom),
              idcomtxt = list(idcomtxt),
              iddep = list(iddep),
              iddeptxt = list(iddeptxt),
              idreg = list(idcom),
              idregtxt = list(idregtxt),
              arthab0920 = sum(arthab0920),
              artact0920 = sum(artact0920),
              artmix0920 = sum(artmix0920),
              artinc0920 = sum(artinc0920),
              surfcom20 = sum(surfcom20))
  
  fCommsL <- gather(fComms, 
                       "variable", 
                       "value",
                     c("arthab0920", "artact0920", "artmix0920", "artinc0920", "surfcom20"))
  
  return(fCommsL)
}
```

### C'est plus simple à présent !
Pour avoir les statistiques sur Aix :
```{r}
flux %>% getStatsComm(codesInsees = "13001") %>% kable
```

Ou les statistiques agrégées sur Aix et une commune voisine appelée Gardanne :
```{r}
flux %>% getStatsComm(codesInsees = c("13001", "13041")) %>% kable
```

## Plot
Maintenant que nous parvenons à récupérer les stats bien formatées, nous pouvons tenter le graphique des flux d'artificialisation sur Aix en Provence :

```{r}
library(ggplot2)

statsAix <- flux %>% 
  getStatsComm("13001") %>% 
  filter(str_detect(variable, "art"))

ggplot(data = statsAix, 
       aes(x = variable, 
           y = value,
           fill = variable)) +
  geom_bar(stat = "identity")
```
C'est vraiment le graphique le plus basique que nous pouvons faire.

Nous pouvons en changer quelques éléments, améliorer l'esthétique :

```{r}
# Filtre des données
statsAix <- flux %>% 
  getStatsComm("13001") %>% 
  filter(str_detect(variable, "art"))

# Libellés
statsAix <- statsAix %>% mutate(variable = case_when(
  variable == "arthab0920" ~ "Habitat",
  variable == "artact0920" ~ "Activité",
  variable == "artmix0920" ~ "Mixte",
  variable == "artinc0920" ~ "Inconnu",
))

# Surfaces en Ha
statsAix$value <- statsAix$value / 10000

# Ordre des barres
# Les plus grands flux en premier
statsAix$variable <- as.character(statsAix$variable)
myLevels <- statsAix$variable[order(statsAix$value)]
statsAix$variable <- factor(statsAix$variable, levels = myLevels)

# Plot
ggplot(data = statsAix, 
       aes(x = variable, 
           y = value,
           fill = variable)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  theme(
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank(),
        panel.border=element_blank(),
        panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),
        legend.position="bottom",
        legend.title=element_blank(),
        legend.text=element_text(size = 8)) +
  scale_y_log10(sec.axis = dup_axis()) +
  scale_fill_discrete(
    name = "Flux\nd'artificialisation\n2009-2020",
    labels = myLevels,
    guide = guide_legend(reverse = TRUE)
  )
```
Nous avons allégé au maximum le graphique.

- scale_y_log10 permet de transformer logarithmiquement l'axe Y
- Nous avons mis la légende en bas pour qu'elle n'écrase pas le graphique
- L'axe des Y (en position horizontale) est dupliqué pour faciliter la lecture

Mais les couleurs ne sont pas forcément encore tops !..

## Couleur
Nous utilisons la modélisation de couleurs HCL (pour Hue Chroma Luminance).

En HCL, une couleur est définie selon tris paramètres :
- Hue, qui définit la teinte (bleue, rouge, ...) d'une couleur
- Chroma son côté coloré (colourfulness)
- Luminance sa luminosité

Nous allons prendre 4 couleurs pour notre palette :
- Bleue pour l'habitat
- Rouge pour l'activité (le rouge rappelle l'activité)
- Magenta pour mixte (un peu un mélange des deux premiers)
- Gris pour la catégorie Inconnu (gris est une couleur neutre qui symbolise bien l'inconnu)

Par défaut, le chroma sera fixé à 50, la luminosité à 80 (sur une échelle de 0 à 100) :
```{r}
library(colorspace)

getColorForHue <- function(h, c = 50, l = 80) {
  hcl(h = h, c = c, l = l, fixup = TRUE)
}

colorBlue <- getColorForHue(220)
colorRed <- getColorForHue(4)
colorMagenta <- getColorForHue(300)
colorGrey <- hcl(h = 0, c = 0, l = 80, fixup = TRUE)

palette <- c(colorBlue, colorRed, colorMagenta, colorGrey)
names(palette) <- c("blue", "red", "magenta", "grey")
```

Testons notre palette :

```{r}
demoplot(palette, "bar")
```
Voici une représentation des couleurs dans l'espace HCL :

```{r}
hclplot(palette)
```

### Fonction
Utilisons cette nouvelle palette de couleurs, et profitons-en pour créer une fonction :

```{r}
makePlot <- function(flux, codesInsees) {
  
  # Filtre des données
  myStats <- flux %>% 
    getStatsComm(codesInsees) %>% 
    filter(str_detect(variable, "art")) # Pas la colonne surfcom20
  
  # Libellés
  myStats <- myStats %>% mutate(variable = case_when(
    variable == "arthab0920" ~ "Habitat",
    variable == "artact0920" ~ "Activité",
    variable == "artmix0920" ~ "Mixte",
    variable == "artinc0920" ~ "Inconnu",
  ))
  
  # Surfaces en Ha
  myStats$value <- myStats$value / 10000
  
  # Ordre des barres
  # Les plus grands flux en premier
  myStats$variable <- as.character(myStats$variable)
  myLevels <- myStats$variable[order(myStats$value)]
  myStats$variable <- factor(myStats$variable, levels = myLevels)
  
  # Couleurs
  palette <- c("Habitat"  = colorBlue, 
               "Activité" = colorRed, 
               "Mixte"    = colorMagenta, 
               "Inconnu"  = colorGrey)
  
  # Plot
  ggplot(data = myStats, 
         aes(x = variable, 
             y = value,
             fill = variable)) +
    geom_bar(stat = "identity") +
    coord_flip() +
    theme(
          axis.text.y=element_blank(),
          axis.ticks.y=element_blank(),
          axis.title.x=element_blank(),
          axis.title.y=element_blank(),
          panel.background=element_blank(),
          panel.border=element_blank(),
          panel.grid.major=element_blank(),
          panel.grid.minor=element_blank(),
          legend.position="bottom",
          legend.title=element_blank(),
          legend.text=element_text(size = 8)) +
    scale_y_log10(sec.axis = dup_axis()) +
    scale_fill_manual(
      name = "Flux\nd'artificialisation\n2009-2020",
      labels = myLevels,
      values = palette[myLevels],
      guide = guide_legend(reverse = TRUE)
    )
}

makePlot(flux, "13001")
makePlot(flux, c("13001", "13041"))
```
### Métropole Aix Marseille Provence
En aparté, pour tester la fonction, faisons un plot pour la métropole Aix Marseille Provence :
```{r}
comms <- st_read("C:/Users/mathieu.rajerison/Documents/DATAS/ADMIN-EXPRESS-COG_2-1__SHP__FRA_L93_2020-03-25/ADMIN-EXPRESS-COG_2-1__SHP__FRA_2020-03-25/ADMIN-EXPRESS-COG/1_DONNEES_LIVRAISON_2020-03-25/ADE-COG_2-1_SHP_LAMB93_FR/COMMUNE_CARTO.shp")

codesInsees <- comms %>% filter(CODE_EPCI == "200054807") %>% pull(INSEE_COM)

makePlot(flux, codesInsees)

```

## Pie plot vs bar plot
Dans le milieu de la Dataviz, il est courant de dire que les camemberts ne sont pas un moyen de visualisation efficace.

Illustrons-le par un petit exemple.

Générons un data frame pour lesquels les différences de valeurs sont subtiles :
```{r}
fooStats <- data.frame(variable = c("Habitat", "Activité", "Mixte", "Inconnu"),
                      value = c(100, 95, 105, 98))
```

Faisons un graphique en barres tout simple :

```{r}
ggplot(fooStats, aes(x = variable, 
                    y = value, 
                    fill = variable)) +
  geom_bar(stat = "identity", width = 1)

```

Faisons le même en camemberts :
```{r}
ggplot(fooStats, aes(x = "", 
                    y = value, 
                    fill = variable)) +
  geom_bar(stat = "identity", width = 1) +
  coord_polar("y", start = 0)
```

On ne voit pas les différences de valeurs entre catégories sur le camembert, mais on les voit bien avec le graphique en barres. L'oeil discerne beaucoup moins bien les différences d'angles !

## Export des données
Exportons nos données de flux :
```{r}
saveRDS(flux, "../shinyapp/app1/flux.rds")
```

----
!! Aller vers le Pradet pour voir la bascule
!! Suivre le littoral
!! Aller sur la Revest Les Eaux (travaux barrage 2011), Chateau Arnoux Saint Auban
https://www.francebleu.fr/infos/meteo/de-gros-travaux-sur-le-barrage-du-revest-les-eaux-pour-anticiper-les-crues-1602086729
http://www.var.gouv.fr/IMG/pdf/a536-avis_mrae_revest-2.pdf